A simple virus contagion simulator
==================================

In March 2020, the Washington Post published an online
[paper](https://www.washingtonpost.com/graphics/2020/world/corona-simulator)
that showed, through different simulations, how the spread of a virus evolves
under different circumstances --such as the now well-known *social distancing*.
Each of the simulations was made of a rectangular area, in the user's browser,
where small circles could move around, bump into (and infect) each other, and
eventually recover.

Depending on how many of them could move, the total and peak number of infected
circles would follow different curves, such as the ones shown below.

![Different curves](https://www.washingtonpost.com/graphics/2020/world/corona-simulator/img/sig-gif.gif)

This project is an attempt at reproducing this simulator, by using a variety
of software tools developed at [Laboratoire d'informatique formelle](https://liflab.ca),
a research lab in Computer Science from [Université du Québec à Chicoutimi](https://www.uqac.ca)
in Québec, Canada. Most notably, the project showcases two important libraries
developed at LIF:

- The [BeepBeep](https://liflab.github.io/beepbeep-3) event stream processing
  engine
- The [Synthia](https://github.com/liflab/synthia) data structure generator

The rest of this Readme explains how the simulator has been built.

[See a video](https://youtu.be/ZlN3X-xJJL0) of the simulator running.

Premise
-------

The Post's simulator works as follows:

1. Circles are randomly placed in a rectangular "arena" and are initially moving
   in randomly selected directions. A varying number of circles can be made
   fixed: they don't move for the entire duration of the simulation.
2. A single circle is initially marked as "infected" (brown); all the other
   circles are "healthy" (light blue).
3. When two circles collide, they bounce off each other; moreover, if one is
   infected and the other is healthy, the healthy one becomes infected.
4. After a fixed amount of time, an infected circle becomes "recovered"
   (purple); it can neither become infected again, nor make other circles
   infected.

Simulating the "arena"
----------------------

In our project, the management of the physics of colliding circles is done
by the package `virussim.physics`. Inside this package, the `Ball` class
implements a simple two-dimensional "ball", with a position and a speed vector,
that can compute elastic collisions with other balls. The `Arena` is just a
set of balls; its method `update` acts like a "tick" that moves the simulation
one step forward: it goes through all `Ball` objects, updates their state, and
determines if any collision occurs.

We shall not elaborate much on this part of the program, as most of the code in
this package is borrowed and adapted from an answer on
[StackOverflow](https://stackoverflow.com/q/345838). One simple adaptation is
that the arena can be asked to output its current state, in the form of a `Map`
linking the unique ID of each ball with the corresponding ball instance.

The `virussim` package defines the `Patient` class, which is a descendent of
`Ball` that can catch a virus when in contact with another infected ball. To
this end, `Patient` has a member field keeping its `Health` state. More on that
later.

Generating the initial state
----------------------------

The initial state of the arena is created by making multiple random "choices"
for each patient. In order to generate this state, we make extensive use of the
`Picker` interface provided by the [Synthia](https://github.com/liflab/synthia)
library. A "picker" is any object that implements a method called `pick()`,
which, when called, returns an object of a certain type. For example,
`RandomInteger` is a picker that returns a randomly selected integer number on
every call to its `pick()` method; the same for `RandomFloat`, `RandomBoolean`,
and so on.

For example, to generate integers in the interval [5,15], a picker can be
created in the following way:

```java
f = new RandomInteger(5, 15);
System.out.println(f.pick());
System.out.println(f.pick());
...
```

The repeated calls to `f.pick()` print the sequence of integers generated by
this picker, e.g.: 8, 6, 9, ...

### Initial position

However, Synthia can generate objects that go beyond random scalars. To generate
each patient's initial position, we use the `PrismPicker`: given two pickers
p1 and p2, this picker generates a 2D vector where the first coordinate is
given by asking p1, and the second coordinate is given by asking p2.

Depending on how these two values are picked, this can correspond to a different
placement of the circles in the arena. Our program provides two options:

- In the first case, p1 and p2 perform an affine transformation of a uniformly
  distributed `float` in the interval [0,1]; in such a case, the circles are
  scattered uniformaly over the arena.
- In the second case, p1 and p2 perform a different affine transformation over
  a `float` that follows a Gaussian distribution. This causes the circles to be
  clustered towards the center of the arena.

For example, the following piece of code creates a picker for floats
following a N(0;1) Gaussian distribution, and creates another picker that turns
it into a N(H/2;H/6) distribution (for some value H):

```java
gf = new GaussianFloat();
at = new AffineTransform.AffineTransformFloat(gh, H/6, H/2);
```

### Initial velocity

Similarly, the initial direction of each patient is given by another 2D vector
specifying its velocity. However, for the sake of elegance, it would be
desirable that the speed of each circle be the same --that is, their velocity
vector can have an arbitrary orientation, but must have the same *modulus*. This
can be done using Synthia's `HyperspherePicker`, which does exactly that: it
takes as input a vector length, and a picker that provides an arbitrary float
value. This value is interpreted as an angle (in radians) in a polar coordinate
system, thus generating vectors of a fixed modulus but with a potentially
varying angle.

```java
float modulus = 5f;
Picker<Float> pf = ...
HypershperePicker hp = new HyperspherePicker(modulus, pf);
```

### Fixed or moving?

Another part of the patient's state that must be specified is whether its
associated circle is fixed or moving. The Post's simulations test various
proportions of moving circles. In our setup, the decision whether a patient is
moving or not is provided by a straightforward `RandomBoolean` picker, which
works like a *biased* coin toss; indeed, we can specify the probability that it
returns true (meaning the patient is fixed) to whatever fraction we wish.

```java
float probability = 0.3f;
RandomBoolean rb = new RandomBoolean(probability);
```

In this example, each call to `rb.pick()` will have a probability of 0.3 of
returning true.

Updating health status
----------------------

In the Post simulation, each sick patient transitions to the "recovered" state
after a fixed amount of time (i.e. a predefined number of simulation steps).
This could be handled with a simple counter variable inside the `Patient`
class; but we chose to implement it using Synthia's picker interface to give
us the possibility to explore other rules for recovery. Therefore, the `Patient`
class has a member field `m_healthPicker` that contains an object implementing
`Picker<Health>` --that is, a picker object that produces values of type
`Health`. Each time this picker is queried, it is intended to return the
patient's health state for the next simulation step.

### First strategy: fixed recovery

The original recovery rule (recover after N steps) can be implemented using a
special type of Synthia picker called `Playback`. This picker is instantiated
with a list of values; it iterates through these values on each call to
`pick()`, until it reaches the last one, which it repeatedly outputs from this
point on.

In our case, we need to create a `Playback` picker that returns `INFECTED` N
times, followed by `RECOVERED` indefinitely. It suffices to instantiate a
`Playback` with the approrpiate values in its list:

```java
Health[] h = new Health[N+1];
for (int i = 0; i < N; i++)
  h[i] = Health.INFECTED;
h[N] = Health.RECOVERED;
Playback pb = new Playback(h);
```

The `Patient` is programmed in such a way that, as long as its current state is
`INFECTED`, its next state in the simulation is given by asking the picker. This
indeed produces the desired behavior.

### Second strategy: Markov chain

However, the fact that a patient uses a picker to update its health state means
that this picker can be replaced by another one if we wish, without having to
change anything in the `Patient` class. As a second strategy, we use another
picker object provided by Synthia which is called the `MarkovChain`.

For the purpose of this project, a [Markov chain](https://en.wikipedia.org/wiki/Markov_chain)
can be seen as a finite-state machine where each transition from one state to
the next is associated to a probability. In Synthia, the `MarkovChain` picker
associates values to each state; repeated calls to its `pick()` method generate
one possible *run* in the chain, where in each state, the next state is selected
with a probability defined by the corresponding transition.

The Markov chain is a handy way of specifying the possible "behaviors" that
something can have. We shall use it to define how a patient can transition from
the `INFECTED` to the `RECOVERED` state. We will also take advantage of the fact
that there can be multiple next states and add a second outcome for a sick
patient, namely that it can transition to an additional health state we call
`DEAD` (hopefully with a very small probability!). Graphically, this is
illustrated by the following state machine:

![Markov chain](Markov.png?raw=true)



<!-- :mode=markdown:maxLineLen=80: -->